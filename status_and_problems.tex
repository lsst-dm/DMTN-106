\section{Status and Problems} \label{sec:statusAndProblems}

\subsection{Status of the implementation} \label{sec:status}

At the time this technote is in writing, March 2019, only the \textbf{lsst\_distrib} package is released and distributed.


\subsubsection{Packaging} \label{sec:statusPkgs}

The following technologies are already used in DM for packaging:

\begin{itemize}
\item {\bf Eups}: for the majority of DM packages. It is used also for all third party libraries that require customization, or that are not available in the conda channels. The lsst DM binary Eups repository is hosted at \url{https://eups.lsst.codes/}. 
\item {\bf Sonatype Nexus}: for java based DM software developed packages.
\item {\bf Conda}: for packages publicly available, that can be used without any customization
\item {\bf Pip/PiPy}: for python packages publicly available.
\end{itemize}


\subsubsection{Distribution} \label{sec:statusDistrib}

The main tool used for distribution to operations is \textbf{Docker}. 

The Science Pipelines distribution to the science comunity is mainly provided using the script \textit{newinstall.sh}. 
This scripts permits to retrieve a specific Science Pipelines build or release available in the Eups repository, and setup the environment for its build and execution.

In \url{pipelines.lsst.io} instructions are provided on how to deploy a Science Pipelines using \textit{newinstall.sh} or \textbf{Docker}.


\subsubsection{SW Products Identification} \label{sec:statusIdentification}

No software products as described in the product tree in \citeds{LDM-294} have official releases. 

Only the Science Pipelines distribution, identified by the \textit{lsst\_distrib} GitHub matapackage, has regular official releases.
All explicit and implicit dependencies in \textit{lsst\_distrib} which team is \textbf{Data Management} or \textbf{DM Externals} are considered part of the distribution.

The following GitHub teams are relevant for the identification of the Science Pipelines distribution:

\begin{itemize}
\item the \textbf{Data Management} team identifies all DM developed software included in the distribution.
\item the \textbf{DM Externals} team identifies third-party libraries required by \textit{lsst\_distrib}.
These are not DM packages, that are not available as public conda packages, or that are updated often and therefore can't be included in the conda environment definition (\ref{sec:statusEnvs}).
See \citeds{DMTN-110} still draft, for current problems and possible solutions.
\end{itemize}

A third team, \textbf{DM Auxiliary}, identifies auxiliary packages to be tagged when a release or build of the distribution is done, but they are not part of it, therefore not distributed with it.


\subsubsection{Environment} \label{sec:statusEnvs}

The conda environment used for building the Science Pipelines is defined in the Git package \textit{scipipe\_conda\_env}.

\textit{TO BE CLARIFIED: how are other build environments managed, for example for java builds?}


\subsubsection{Other Tools} \label{sec:statusTools}

The build tools used to build Science Pipelines software are available in \textit{lsstsw} and \textit{lsst\_build} Git packages.

The Jenkins scripts also are an important part of the tooling, facilitating a large number of actions, like, test a ticket branch, automate releases, or provide periodic build (weekly/daily).

The tools picture is completed by \textit{codekit}, which permits interaction with multiple GitHub packages.
Just as an example, it is used to create the same tag on all the GitHub packages composing a defined product automatically, instead of creating it manually.

\textit{TO BE CLARIFIED: which are the tools used with other build systems, like for example java?}


\subsection{Open Problems} \label{sec:openProblems}

In this section, a list of problems derived from the current development approach is enumerated. 

While these problems are unresolved the only release process suitable for DM is to release the entire codebase each time.

Their resolution may lead to a different development approach, and therefore the proposed release procedure may need to be reviewed accordingly.


\subsubsection{SW Product Composition} \label{sec:problemId}

A GitHub package may be included in more than one software product.

This makes impossible to apply in a consistent way the release procedure to an SW product that is not the Science Pipelines.
The reason is explained in the following example.

Product A is composed of 100 Git packages.

Product B is composed of 80 Git packages.

70 Git packages are shared by both products.

When release 1.0 is done on product A, all 100 packages will be tagged, and corresponding Eups packages are created. This will include the 70 shared packages.

One week later, product B is ready for the release 1.0, and some of the 70 shared packages have been updated.
For them, the 1.0 tag required for product B release, will not be the same as the 1.0 tag required for the product A release.
This implies that for some packages, release 1.0 of product A, is different from release 1.0 of product B.

\textbf{Requirement}: there should be a 1 to 1 correspondence between software products and GitHub packaged. 
If this is not possible, each GitHub package shall be included in only one software product (one SW product to many Git packages).
Note also that, each GitHub package used for building, unit testing and packaging the software products shall not be included in the SW product itself, but versioned separately and be part of the environment definition. See section \ref{sec:swprod}.


\subsubsection{Code Fragmentation} \label{sec:problemCode}

The high number of packages causes problems in that it :

\begin{itemize}
\item increases the build time: each Git package needs to build each time.
\item increases the release time: all Git packages need to be built and released each time.
\item increases the failure probability: the tooling may be affected by network glitch or similar technical issues. 
This may lead to the failure of the build/release process in a non-deterministic way.
\end{itemize}

Moving 3rd party libraries to conda environment will mitigate these problem. 
However, this requires proper management of the conda environment. See draft \citeds{DMTN-110}.

\textbf{Requirement}: the number of Git packages shall be kept low. DM-CCB shall approve each time a new package is introduced since this has an impact on the maintainability of the system. 
All third party libraries, shall also not be part of the stack, if not requiring source code changes.


\subsubsection{Binaries Persistence} \label{sec:problemPersistence}

Each time we do a build, all Git packages and rebuild. However, if the package is already installed in the local environment and is not affected by any changes, it will not be rebuilt.

In reality, once a package has been built, and the corresponding binaries have been made available, for a specific platform (linux, macOS, etc), in the package repository (\url{https://eups.lsst.codes/}),
it shall be possible for all the downstream users, to use it without building it again.

A GitHub package should be rebuilt, only in case its source code has changed, or one of its dependencies has changed (in case of semantic versioning, only for breaking changes that increase the major version).

\textbf{Requirement}: it shall be possible to resolve the package binaries from \url{https://eups.lsst.codes/} if available, instead of building them from the source code.

This problem is not blocking on the release process, but its resolution permits optimization of the build.


